---
title: "01: Getting Data"
output: 
  html_document:
    highlight: pygment
---

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      class.source = "numberLines lineAnchors",
                      warning = FALSE, message = FALSE,
                      eval = TRUE)
```

## TL;DR

This section is all about getting data for visualization. You will stream COVID data from the NYTimes and join the most current data county centroids. if you haven't yet installed R and RStudio - or set up your COVID-19-dashboard project - please revist [here](00_setting_up_the_project.html)

## Introduction

To make our Shiny Application we first need data! In this section we are going to build `functions` to generate  datasets that will be used in the application. These include:

1. A `county-level timeseries` of the most up to data COVID-19 cases and deaths
2. A spatial dataset of the `county centroids joined to 'todays' COVID-19 counts`.

## Streaming COVID-19 Timeseries Data

The *New York Times* archives a daily record of county-level USA COVID-19 cases and deaths in a GitHub repository [here](https://github.com/nytimes/covid-19-data). 

In this repository the most current, raw, CSV can be accessed at the following URL:

```{r}
url ='https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv'
```

R is really cool, and lets read this URL directly R using the `read.csv`: 

```{r, eval = TRUE}
# Here we are reading the URL directly using the url variable created above
covid19 = read.csv(url)
```

and look at it using the head() function to print the first few rows:

```{r, eval = TRUE}
head(covid19)
```

**That was easy!** `r emo::ji("smile")`

Now lets look at the structure (str) of the data:

```{r, eval =TRUE}
str(covid19)
```

Things look pretty good but lets change or date values to  `date` objects for nicer plotting.  

We will also add a new variable called "name" which is a pretty-text string combinign the county and state names. Here we use the `dplyr` keyword `mutate` which allows us to create or transform variables. Since we are using `mutate` we need to attach the `dplyr` package.

```{r, eval = TRUE}
library(dplyr)

covid19  = covid19 %>% 
  mutate(date = as.Date(date), # Override date with formated date
         name = paste0(county, " County, ", state)) # Make a new text string

## Lets check!
str(covid19)
```

Great! Now we see that date is in fact a date objec, and name give us the combined state county name.
Now lets us see how the data works using LA County (FIP = 6037) as an example. Here we are relaying of the `dplyr` `filter` keyword to return rows mathcing a prescribed condtion. Since dplyr was alreay attached above, we do not need to re-attach the package.

```{r, eval = TRUE}
# Filter the covid19 data to only those reocords were fips equals 6037
test = filter(covid19, fips == 6037)

# Plot the data
plot(x = test$date, # define the x axis variable
     y = test$cases, # define the y axis variable
     type  = "l", # we wnat a line "l" plot
     xlab = "Date", ylab = "Cases", # refine the x and y labels
     main = test$name[1]) # define the plot title.

```

### Getting Spatial Data for the Counties:

There are many ways to get spatial data into R. I have saved the USA low-resolution county geometries [here](). You can download it, save it into your `data folder`, attach the `sf` library, read the RDS file, and plot the geometry attributes of the data!

```{r, message=FALSE, eval = TRUE}
library(sf) # Attach sf library

counties = readRDS("./data/counties.rds") # read rds data

plot(counties$geometry) # plot the county geometries
```


### Getting county centroids and joing to COVID data

Great! Now we have a spatial representation of all continental USA counties and a time series of COVID-19 cases and deaths. Lets create a new dataset that joins the most current daily statistics to the spatial geomertries. For faster rendering, we will convert the county polygons into centroids using the following steps:

1. Filter our `covid19_data` to the the most current (maximum) date
2. Join it to the counties using the shared `fips` variable, 
3. Remove NA values
4. scale the cases to determine a realtive scales, case count.

```{r, warning=FALSE}

today = filter(covid19, date == max(date)) %>% # filter all data to the maximum datae
  left_join(st_centroid(counties), by = 'fips') %>%  # cast county geometries to centroid, and join by fip
  na.omit() %>% # remove NA values
  mutate(size = abs(cases - mean(cases)) / sd(cases)) # Compute a scaled case count
  

# Plot and size the shaped by the scaled size value
plot(today$geometry, cex = today$size)
```

## Adding Data Functions to `helpers.R`

Now lets turn the above processes into `functions` that we can call at anytime to our helpers.R file. 

You can either type them in or use the copy icon to put these in your `helpers.R` file

```{r}

# This function takes a URL and modifies the attributes are discussed above. Once all these things are done, the formated data is returned as output
read_covid19 = function(url){
  read.csv(url) %>% 
  mutate(date = as.Date(date), 
         name = paste0(county, " County, ", state))
}

# Here we require the user to provide the counties and COVID data. In the functions, the centroids are computed and joined to the COVID-19 data.

today_centroids = function(counties, covid_data){
  filter(covid_data, date == max(date)) %>% 
  left_join(st_centroid(counties), by = 'fips') %>% 
  na.omit() %>% 
  mutate(size = abs(cases - mean(cases)) / sd(cases)) %>% 
  st_as_sf()
}
```

## Conclusion

Fantastic, now we have methods and data needed to build our Shiny App. Lets move to the next [section](02_graphs.html) where we will make interactive graphs of our timeseries data using the `dyGraphs` package. 