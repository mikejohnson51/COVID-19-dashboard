---
title: "03_Shiny_Basics"
author: "Mike Johnson"
date: "4/3/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Shiny Basics

Start by creating a new R file in you 'COVID-19-dashboard' directory. Call this file 'app.R'.

In the top of this file, lets put what we have already developed. These include loading the needed packages, loading the county data, sourcing our helper functions, and initializing the COVID data.

```{r, eval = FALSE}
# 1. Load packages ----

# Data Manipulation
library(dplyr) # data.frames
library(sf)    # Spatial

# Interactive Data Viz
library(leaflet)  # Maps
library(dygraphs) # Charts
library(DT)       # tables

# Shiny
library(shiny)    # Starting Reactivity

# 2. Load data ----
counties <- readRDS("data/counties.rds")

# Source helper functions -----
source("helpers.R")

# 3. Initalize data
covid19_data <-  read_covid19()
today        <-  today_centroids(counties, covid19_data)
leaf_map     <-  base_leaf(today)
```

In the last section we build functions that would generate tables (make_DT) and charts (make_graph) or modify a map (zoom_to_county) based on a provided FIP code. Shiny is a system that lest you build interactive web applications that let selections be made in a user interface (UI), that can be change, or change, processes that happen in a 'server'.

Shiny applications have two components, a user interface object and a server function, that are passed as arguments to the shinyApp function that creates a Shiny app object from this UI/server pair. The source code for both of these components is listed below.



First lets 

The Shiny web framework is fundamentally about making it easy to wire up input values from a web page, making them easily available to you in R, and have the results of your R code be written as output values back out to the web page.

Since Shiny web apps are interactive, the input values can change at any time, and the output values need to be updated immediately to reflect those changes.

Shiny comes with a reactive programming library that you will use to structure your application logic. By using this library, changing input values will naturally cause the right parts of your R code to be reexecuted, which will in turn cause any changed outputs to be updated




A fluid page layout consists of rows which in turn include columns. Rows exist for the purpose of making sure their elements appear on the same line (if the browser has adequate width). Columns exist for the purpose of defining how much horizontal space within a 12-unit wide grid it's elements should occupy. Fluid pages scale their components in realtime to fill all available browser width.

```{r, eval = FALSE}

# 4. User interface ----
ui <- fluidPage( )

# 5. Server logic ----
server <- function(input, output) { }

```

## For our purposes an application can be run 

```{r, eval = FALSE}
runApp(shinyApp(ui, server), launch.browser = TRUE)
```